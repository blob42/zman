#!/usr/bin/env bash
# zman: interactive fzf man-pages browser
set -e

sections=""
FZF_MAN_SECTIONS_SCRIPT=~/scripts/fzf/fzf_zman_sections
OFS="$IFS"
AICHAT_DEFAULT_MODEL="ollama:gemma3:4b"

# @flag -g --gen Generate man keywords
# @flag -d --debug
# @option -s --sections
# @arg query*

usage(){
    echo "Usage: $0 [-h] [-v] [-s section[,section ...]]"
    echo "  -h, --help     Show help and exit"
    echo "  -s, --section  Specify comma separated list of man page sections"
}

error(){
  echo "error message $1"
  dunstify -u critical $1
  exit 40
}


ai_gen_keywords(){
    read -p "ai-man topic: " -r input_query
    command -v aichat >/dev/null || errquit 'missing aichat'
    [ "$(aichat --list-roles | grep zman-keywords)" ] || errquit 'missing role zman-keywords'
    aichat -m $AICHAT_DEFAULT_MODEL -r zman-keywords "$input_query"
}


# ARGC-BUILD {
# This block was generated by argc (https://github.com/sigoden/argc).
# Modifying it manually is not recommended

_argc_run() {
    if [[ "${1:-}" == "___internal___" ]]; then
        _argc_die "error: unsupported ___internal___ command"
    fi
    if [[ "${OS:-}" == "Windows_NT" ]] && [[ -n "${MSYSTEM:-}" ]]; then
        set -o igncr
    fi
    argc__args=("$(basename "$0" .sh)" "$@")
    argc__positionals=()
    _argc_index=1
    _argc_len="${#argc__args[@]}"
    _argc_tools=()
    _argc_parse
    if [ -n "${argc__fn:-}" ]; then
        $argc__fn "${argc__positionals[@]}"
    fi
}

_argc_usage() {
    cat <<-'EOF'
USAGE: zman [OPTIONS] [QUERY]...

ARGS:
  [QUERY]...

OPTIONS:
  -g, --gen                  Generate man keywords
  -d, --debug
  -s, --sections <SECTIONS>
  -h, --help                 Print help
  -V, --version              Print version
EOF
    exit
}

_argc_version() {
    echo zman 0.0.0
    exit
}

_argc_parse() {
    local _argc_key _argc_action
    local _argc_subcmds=""
    while [[ $_argc_index -lt $_argc_len ]]; do
        _argc_item="${argc__args[_argc_index]}"
        _argc_key="${_argc_item%%=*}"
        case "$_argc_key" in
        --help | -help | -h)
            _argc_usage
            ;;
        --version | -version | -V)
            _argc_version
            ;;
        --)
            _argc_dash="${#argc__positionals[@]}"
            argc__positionals+=("${argc__args[@]:$((_argc_index + 1))}")
            _argc_index=$_argc_len
            break
            ;;
        --gen | -g)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--gen\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_gen:-}" ]]; then
                _argc_die "error: the argument \`--gen\` cannot be used multiple times"
            else
                argc_gen=1
            fi
            ;;
        --debug | -d)
            if [[ "$_argc_item" == *=* ]]; then
                _argc_die "error: flag \`--debug\` don't accept any value"
            fi
            _argc_index=$((_argc_index + 1))
            if [[ -n "${argc_debug:-}" ]]; then
                _argc_die "error: the argument \`--debug\` cannot be used multiple times"
            else
                argc_debug=1
            fi
            ;;
        --sections | -s)
            _argc_take_args "--sections <SECTIONS>" 1 1 "-" ""
            _argc_index=$((_argc_index + _argc_take_args_len + 1))
            if [[ -z "${argc_sections:-}" ]]; then
                argc_sections="${_argc_take_args_values[0]:-}"
            else
                _argc_die "error: the argument \`--sections\` cannot be used multiple times"
            fi
            ;;
        *)
            if _argc_maybe_flag_option "-" "$_argc_item"; then
                _argc_die "error: unexpected argument \`$_argc_key\` found"
            fi
            argc__positionals+=("$_argc_item")
            _argc_index=$((_argc_index + 1))
            ;;
        esac
    done
    if [[ -n "${_argc_action:-}" ]]; then
        $_argc_action
    else
        if [[ "${argc__positionals[0]:-}" == "help" ]] && [[ "${#argc__positionals[@]}" -eq 1 ]]; then
            _argc_usage
        fi
        _argc_match_positionals 1
        local values_index values_size
        IFS=: read -r values_index values_size <<<"${_argc_match_positionals_values[0]:-}"
        if [[ -n "$values_index" ]]; then
            argc_query=("${argc__positionals[@]:values_index:values_size}")
        fi
    fi
}

_argc_take_args() {
    _argc_take_args_values=()
    _argc_take_args_len=0
    local param="$1" min="$2" max="$3" signs="$4" delimiter="$5"
    if [[ "$min" -eq 0 ]] && [[ "$max" -eq 0 ]]; then
        return
    fi
    local _argc_take_index=$((_argc_index + 1)) _argc_take_value
    if [[ "$_argc_item" == *=* ]]; then
        _argc_take_args_values=("${_argc_item##*=}")
    else
        while [[ $_argc_take_index -lt $_argc_len ]]; do
            _argc_take_value="${argc__args[_argc_take_index]}"
            if _argc_maybe_flag_option "$signs" "$_argc_take_value"; then
                if [[ "${#_argc_take_value}" -gt 1 ]]; then
                    break
                fi
            fi
            _argc_take_args_values+=("$_argc_take_value")
            _argc_take_args_len=$((_argc_take_args_len + 1))
            if [[ "$_argc_take_args_len" -ge "$max" ]]; then
                break
            fi
            _argc_take_index=$((_argc_take_index + 1))
        done
    fi
    if [[ "${#_argc_take_args_values[@]}" -lt "$min" ]]; then
        _argc_die "error: incorrect number of values for \`$param\`"
    fi
    if [[ -n "$delimiter" ]] && [[ "${#_argc_take_args_values[@]}" -gt 0 ]]; then
        local item values arr=()
        for item in "${_argc_take_args_values[@]}"; do
            IFS="$delimiter" read -r -a values <<<"$item"
            arr+=("${values[@]}")
        done
        _argc_take_args_values=("${arr[@]}")
    fi
}

_argc_match_positionals() {
    _argc_match_positionals_values=()
    _argc_match_positionals_len=0
    local params=("$@")
    local args_len="${#argc__positionals[@]}"
    if [[ $args_len -eq 0 ]]; then
        return
    fi
    local params_len=$# arg_index=0 param_index=0
    while [[ $param_index -lt $params_len && $arg_index -lt $args_len ]]; do
        local takes=0
        if [[ "${params[param_index]}" -eq 1 ]]; then
            if [[ $param_index -eq 0 ]] &&
                [[ ${_argc_dash:-} -gt 0 ]] &&
                [[ $params_len -eq 2 ]] &&
                [[ "${params[$((param_index + 1))]}" -eq 1 ]] \
                ; then
                takes=${_argc_dash:-}
            else
                local arg_diff=$((args_len - arg_index)) param_diff=$((params_len - param_index))
                if [[ $arg_diff -gt $param_diff ]]; then
                    takes=$((arg_diff - param_diff + 1))
                else
                    takes=1
                fi
            fi
        else
            takes=1
        fi
        _argc_match_positionals_values+=("$arg_index:$takes")
        arg_index=$((arg_index + takes))
        param_index=$((param_index + 1))
    done
    if [[ $arg_index -lt $args_len ]]; then
        _argc_match_positionals_values+=("$arg_index:$((args_len - arg_index))")
    fi
    _argc_match_positionals_len=${#_argc_match_positionals_values[@]}
    if [[ $params_len -gt 0 ]] && [[ $_argc_match_positionals_len -gt $params_len ]]; then
        local index="${_argc_match_positionals_values[params_len]%%:*}"
        _argc_die "error: unexpected argument \`${argc__positionals[index]}\` found"
    fi
}

_argc_maybe_flag_option() {
    local signs="$1" arg="$2"
    if [[ -z "$signs" ]]; then
        return 1
    fi
    local cond=false
    if [[ "$signs" == *"+"* ]]; then
        if [[ "$arg" =~ ^\+[^+].* ]]; then
            cond=true
        fi
    elif [[ "$arg" == -* ]]; then
        if (( ${#arg} < 3 )) || [[ ! "$arg" =~ ^---.* ]]; then
            cond=true
        fi
    fi
    if [[ "$cond" == "false" ]]; then
        return 1
    fi
    local value="${arg%%=*}"
    if [[ "$value" =~ [[:space:]] ]]; then
        return 1
    fi
    return 0
}

_argc_die() {
    if [[ $# -eq 0 ]]; then
        cat
    else
        echo "$*" >&2
    fi
    exit 1
}

_argc_run "$@"

# ARGC-BUILD }

if [[ "$argc_debug" -eq 1 ]]; then
     echo gen: $argc_gen
     echo sections: ${argc_sections[@]}
     echo query: ${argc_query[@]}
fi
# exit 0


query="${argc_query[@]}"
sections="$argc_sections"
prompt="($query)> "

if [[ "$argc_gen" -eq 1 ]]; then
    query="$(ai_gen_keywords)"
    query=$(echo -n "$query" | sed -E "s/(\w+) (\w+)/'\1 \2'/g")
    prompt="(ai)> "

    if [[ "$argc_debug" -eq 1 ]]; then
        echo "$query"
    fi
fi


if [[ $query =~ "|" ]];then
    prompt="(ai)> "
fi


pre_query=""
if [ -n "$sections" ]; then
    pre_query="-S $sections"
fi

if [ -z "$query" ]; then
    query="."
fi

#query="dlopen|dlsym|dlclose|dynamic linking|shared library|loadlibrary|rt_mutex|rt_thread"
# echo "query: $query"
# --preview "echo topic={1} section=\$(echo {2} | tr -d '()')" \

# disable IFS for regex queries gives narrower results
# this is only done for the initial result from ai, after calling fzf_zman_sections
# IFS should not be cleared
# if [[ $query =~ "ai:" ]];then
    # IFS=''
#     query="${query#ai:}"
#     echo zman: $query >> /tmp/zman_debug
# fi
 man $pre_query -k $query | fzf --header-first --prompt="$prompt" \
    --preview "man \$(echo {2} | tr -d '()') {1} 2>/dev/null | col -bx | bat -l man -p --color always" \
    --bind "alt-enter:reload-sync(man $pre_query -k {q})+transform-prompt(printf '(%s)> ' \$FZF_QUERY)+clear-query" \
    --bind "alt-a:become(zman -g)" \
    --bind "ctrl-s:become($FZF_MAN_SECTIONS_SCRIPT \"$query\" \$FZF_PROMPT)" \
    --bind "enter:become(echo {} | tr -d '()' | awk '{printf \"%s \", \$2} {print \$1}' | xargs -r man)" \
    --header 'A-Ent: update query. C-s: sections: A-a: AI.  Ent: Choose.'
